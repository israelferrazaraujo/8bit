#include "../fixed/fixed.h"
#include "trig.h"
#include <math.h>

#define INT16_BITS (8 * sizeof(int))
#define INT16_MAX  ((1<<(INT16_BITS-1))-1)

#define TABLE_BITS (6)
#define TABLE_SIZE (1<<TABLE_BITS)
#define TABLE_MASK (TABLE_SIZE-1)
 
/*
 * The lookup table is to 90DEG, the input can be -360 to 360 DEG, where negative
 * values are transformed to positive before further processing. We need two
 * additional bits (*4) to represent 360 DEG:
 */
#define LOOKUP_BITS (TABLE_BITS+2)
#define LOOKUP_MASK ((1<<LOOKUP_BITS)-1)
#define FLIP_BIT    (1<<TABLE_BITS)
#define NEGATE_BIT  (1<<(TABLE_BITS+1))
#define INTERP_BITS (INT16_BITS-1-LOOKUP_BITS)
#define INTERP_MASK ((1<<INTERP_BITS)-1)

#define RAD_TO_N15  ((float)(INT16_MAX)/TWO_PI)
#define Q15         (1.0f/(float)INT16_MAX)

#define nTWO_PI     INT16_MAX // N15 TWO_PI
#define nHALF_PI    (nTWO_PI>>2) // N15 HALF_PI = nTWO_PI/4

#define xTWO_PI     6433 // fixed point TWO_PI  (int)(TWO_PI  * (1<<10))
#define xHALF_PI    1608 // fixed point HALF_PI (int)(HALF_PI * (1<<10))
#define BITS_DIFF   5    // difference between Q15 and fixed fractional bits representation

/**
 * "5 bit" lookup table for the offsets. These are the sines for exactly
 * at 0deg, 11.25deg, 22.5deg etc. The values are from -1 to 1 in Q15.
 */
/*
static const int sin90[] = {
  0x0000,0x0647,0x0c8b,0x12c7,0x18f8,0x1f19,0x2527,0x2b1e,
  0x30fb,0x36b9,0x3c56,0x41cd,0x471c,0x4c3f,0x5133,0x55f4,
  0x5a81,0x5ed6,0x62f1,0x66ce,0x6a6c,0x6dc9,0x70e1,0x73b5,
  0x7640,0x7883,0x7a7c,0x7c29,0x7d89,0x7e9c,0x7f61,0x7fd7,
  0x7fff
};
*/
// 6 bit
static const int sin90[TABLE_SIZE+1] = {
  0x0000,0x0324,0x0647,0x096a,0x0c8b,0x0fab,0x12c7,0x15e1,
  0x18f8,0x1c0b,0x1f19,0x2223,0x2527,0x2826,0x2b1e,0x2e10,
  0x30fb,0x33de,0x36b9,0x398c,0x3c56,0x3f16,0x41cd,0x447a,
  0x471c,0x49b3,0x4c3f,0x4ebf,0x5133,0x539a,0x55f4,0x5842,
  0x5a81,0x5cb3,0x5ed6,0x60eb,0x62f1,0x64e7,0x66ce,0x68a5,
  0x6a6c,0x6c23,0x6dc9,0x6f5e,0x70e1,0x7254,0x73b5,0x7503,
  0x7640,0x776b,0x7883,0x7989,0x7a7c,0x7b5c,0x7c29,0x7ce2,
  0x7d89,0x7e1c,0x7e9c,0x7f08,0x7f61,0x7fa6,0x7fd7,0x7ff5,
  0x7fff
};

// 8 bit
/*
static const int sin90[TABLE_SIZE+1] = {
  0x0000,0x00c9,0x0192,0x025b,0x0324,0x03ed,0x04b6,0x057e,
  0x0647,0x0710,0x07d9,0x08a1,0x096a,0x0a32,0x0afb,0x0bc3,
  0x0c8b,0x0d53,0x0e1b,0x0ee3,0x0fab,0x1072,0x1139,0x1200,
  0x12c7,0x138e,0x1455,0x151b,0x15e1,0x16a7,0x176d,0x1833,
  0x18f8,0x19bd,0x1a82,0x1b46,0x1c0b,0x1ccf,0x1d93,0x1e56,
  0x1f19,0x1fdc,0x209f,0x2161,0x2223,0x22e4,0x23a6,0x2467,
  0x2527,0x25e7,0x26a7,0x2767,0x2826,0x28e5,0x29a3,0x2a61,
  0x2b1e,0x2bdb,0x2c98,0x2d54,0x2e10,0x2ecc,0x2f86,0x3041,
  0x30fb,0x31b4,0x326d,0x3326,0x33de,0x3496,0x354d,0x3603,
  0x36b9,0x376f,0x3824,0x38d8,0x398c,0x3a3f,0x3af2,0x3ba4,
  0x3c56,0x3d07,0x3db7,0x3e67,0x3f16,0x3fc5,0x4073,0x4120,
  0x41cd,0x4279,0x4325,0x43d0,0x447a,0x4523,0x45cc,0x4674,
  0x471c,0x47c3,0x4869,0x490e,0x49b3,0x4a57,0x4afa,0x4b9d,
  0x4c3f,0x4ce0,0x4d80,0x4e20,0x4ebf,0x4f5d,0x4ffa,0x5097,
  0x5133,0x51ce,0x5268,0x5301,0x539a,0x5432,0x54c9,0x555f,
  0x55f4,0x5689,0x571d,0x57b0,0x5842,0x58d3,0x5963,0x59f3,
  0x5a81,0x5b0f,0x5b9c,0x5c28,0x5cb3,0x5d3d,0x5dc6,0x5e4f,
  0x5ed6,0x5f5d,0x5fe2,0x6067,0x60eb,0x616e,0x61f0,0x6271,
  0x62f1,0x6370,0x63ee,0x646b,0x64e7,0x6562,0x65dd,0x6656,
  0x66ce,0x6745,0x67bc,0x6831,0x68a5,0x6919,0x698b,0x69fc,
  0x6a6c,0x6adb,0x6b4a,0x6bb7,0x6c23,0x6c8e,0x6cf8,0x6d61,
  0x6dc9,0x6e30,0x6e95,0x6efa,0x6f5e,0x6fc0,0x7022,0x7082,
  0x70e1,0x7140,0x719d,0x71f9,0x7254,0x72ae,0x7306,0x735e,
  0x73b5,0x740a,0x745e,0x74b1,0x7503,0x7554,0x75a4,0x75f3,
  0x7640,0x768d,0x76d8,0x7722,0x776b,0x77b3,0x77f9,0x783f,
  0x7883,0x78c6,0x7908,0x7949,0x7989,0x79c7,0x7a04,0x7a41,
  0x7a7c,0x7ab5,0x7aee,0x7b25,0x7b5c,0x7b91,0x7bc4,0x7bf7,
  0x7c29,0x7c59,0x7c88,0x7cb6,0x7ce2,0x7d0e,0x7d38,0x7d61,
  0x7d89,0x7db0,0x7dd5,0x7df9,0x7e1c,0x7e3e,0x7e5e,0x7e7e,
  0x7e9c,0x7eb9,0x7ed4,0x7eef,0x7f08,0x7f20,0x7f37,0x7f4c,
  0x7f61,0x7f74,0x7f86,0x7f96,0x7fa6,0x7fb4,0x7fc1,0x7fcd,
  0x7fd7,0x7fe0,0x7fe8,0x7fef,0x7ff5,0x7ff9,0x7ffc,0x7ffe,
  0x7fff
};
*/

/**
 * Sine calculation using interpolated table lookup.
 * Instead of radiants or degrees we use "turns" here. Means this
 * sine does NOT return one phase for 0 to 2*PI, but for 0 to 1.
 * Input: -1 to 1 as int16 Q15  == -32768 to 32767.
 * Output: -1 to 1 as int16 Q15 == -32768 to 32767.
 *
 * See the full description at www.AtWillys.de for the detailed
 * explanation.
 */
static int v0, v1;
static int sin(int angle)
{
  v0 = (angle >> INTERP_BITS);
  if (v0 & FLIP_BIT) { v0 = ~v0; v1 = ~angle; } else { v1 = angle; }
  v0 &= TABLE_MASK;
  v1 = sin90[v0] + (int)(((long)(sin90[v0+1]-sin90[v0]) * (v1 & INTERP_MASK)) >> INTERP_BITS);
  //v1 = (int)( sin90[v0] + (((sin90[v0+1]-sin90[v0]) * (v1 & INTERP_MASK)) >> INTERP_BITS) );
  //v1 = sin90[v0] + (int)(((unsigned int)(sin90[v0+1]-sin90[v0]) * (v1 & INTERP_MASK)) >> INTERP_BITS);
  //v1 = sin90[v0] + (((sin90[v0+1]-sin90[v0]) * (v1 & INTERP_MASK)) >> INTERP_BITS);
  if ((angle >> INTERP_BITS) & NEGATE_BIT) v1 = -v1;

  return v1;
}


/**
 * Input: angle in radians (float). 
 * Output: sin of the angle (float).
 */
inline float fsin(float angle)
{
  //while (angle<0.0f)    angle+=TWO_PI;
  //while (angle>=TWO_PI) angle-=TWO_PI;

  return sin((int)(RAD_TO_N15 * angle)) * Q15;
}
/**
 * Input: angle in radians (float). 
 * Output: cos of the angle (float).
 */
inline float fcos(float angle)
{
  //return fsin(HALF_PI - angle);
  return fsin(HALF_PI >= angle ? HALF_PI - angle : HALF_PI + TWO_PI - angle);
}

/**
 * Input: angle in radians (N15). 
 * Output: sin of the angle (N15).
 */
inline int nsin(int angle)
{
  return sin(angle);
}
/**
 * Input: angle in radians (N15). 
 * Output: cos of the angle (N15).
 */
inline int ncos(int angle)
{
  return nsin(nHALF_PI >= angle ? nHALF_PI - angle : nHALF_PI + nTWO_PI - angle);
}

/**
 * Input: angle in radians (fixed). 
 * Output: sin of the angle (fixed).
 */
inline fixed xsin(fixed angle)
{
  return sin(fixed_div(angle, xTWO_PI) << BITS_DIFF) >> BITS_DIFF;
}
/**
 * Input: angle in radians (fixed). 
 * Output: cos of the angle (fixed).
 */
inline fixed xcos(fixed angle)
{
  return xsin(xHALF_PI >= angle ? xHALF_PI - angle : xHALF_PI + xTWO_PI - angle);
}